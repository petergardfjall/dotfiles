# General

For local documentation: Use `godoc-open.sh` or `godoc -http localhost:1234`.

## Types
Go's basic types are:

- boolean: `bool`
- string: `string`
- integer numbers: `int`, `int8`, `int16`, `int32`, `int64`, `uint`, `uint8`,
  `uint16`, `uint32`, `uint64`, `uintptr`,`byte` (alias for `uint8`), `rune`
  (alias for `int32` -- represents a Unicode code point).

  The `int`, `uint`, and `uintptr` types are usually 32 bits wide on 32-bit
  systems and 64 bits wide on 64-bit systems. Use `int` unless you have a
  specific reason to use a sized or unsigned integer type.

- floating point numbers: `float32`, `float64`
- complex numbers: `complex64`, `complex128`

The *zero value* is:
- `0` for numeric types,
- `false` for the boolean type, and
- `""` (the empty string) for strings.

`T(v)` converts the value `v` to the type `T`:

    i := 42
    f := float64(i)


A *type assertion* provides access to an interface value's underlying concrete
value.

    var i interface{} = "hello"
    s := i.(string)
    fmt.Println(s)

If `i` does not hold a `string`, the statement will trigger a panic.

To test whether an interface value holds a specific type, a type assertion can
return two values: the underlying value and a boolean value that reports whether
the assertion succeeded.

     t, ok := i.(T)

Constants can be character, string, boolean, or numeric values.

    const (
        Pi = 3.14
        E  = 2.71
    )

## Builtin

Package `builtin` provides *documentation* (they aren't actually declared there)
for built-in identifiers: https://golang.org/pkg/builtin/.

Examples are:
- output: `print`, `println`
- slices: `append`, `copy`
- map: `delete`
- creation: `new` (allocate memory for a type), `make` (chan, slice, map)
- size: `len`,  `cap`
- channels: `close(c chan<- Type)`
- error handling: `panic`, `recover`

## Switch

Use commas to separate multiple expressions in a single `case`:

    switch time.Now().Weekday() {
    case time.Saturday, time.Sunday:
        fmt.Println("It's the weekend")
    default:
        fmt.Println("It's a weekday")
    }

An alternative to an `if-else` is to use a `switch` without expression:

    switch {
    case t.Hour() < 12:
        fmt.Println("It's before noon")
    default:
        fmt.Println("It's after noon")
    }

Use a "type switch" to compare types instead of values:

    whatAmI := func(i interface{}) {
        switch t := i.(type) {
        case bool:
            fmt.Println("I'm a bool")
        case int:
            fmt.Println("I'm an int")
        default:
            fmt.Printf("Don't know type %T\n", t)
        }
    }
    whatAmI(true)
    whatAmI(1)
    whatAmI("hey")


Switch cases evaluate cases from top to bottom, stopping when a case succeeds.

    // does not call `f` if `i==0`.
    switch i {
    case 0:
    case f():
    }

Each `case` can be an expression. For example `today + 1`.


## Defer

A defer statement defers the execution of a function until the surrounding
function returns. The deferred call's arguments are evaluated immediately, but
the function call is not executed until the surrounding function returns.
Deferred function calls are pushed onto a stack. When a function returns, its
deferred calls are executed in LIFO order. This reclaims resources in opposite
order of acquisition.

    f, err := os.Open(path)
    if err != nil {
        return nil, errors.Wrap(err, "open failed")
    }
    defer f.Close()
    ...

## Formatting

The formatted I/O from package `fmt` supports these format specifiers:

General:
- `%v`: the value in a default format.For compound objects, the elements are
  printed using these rules, recursively, laid out like this:

        struct:             {field0 field1 ...}
        array, slice:       [elem0 elem1 ...]
        maps:               map[key1:value1 key2:value2 ...]
        pointer to above:   &{}, &[], &map[]

- `%+v`: same as `%v`, but When printing `struct`s, field names are written
- `%#v`: a Go-syntax representation of the value.
- `%T`:  a Go-syntax representation of the *type* of the value.
- `%%`:  a literal percent sign; consumes no value

Boolean:
- `%t`: the word `true` or `false`.

Integer:
- `%b`: base 2
- `%c`: the character represented by the corresponding Unicode code point
- `%d`: base 10
- `%o`: base 8
- `%q`: a single-quoted character literal safely escaped with Go syntax.
- `%x`: base 16, with lower-case letters for a-f
- `%X`: base 16, with upper-case letters for A-F
- `%U`: Unicode format: U+1234; same as "U+%04X"

Floating-point:
- `%b`: decimalless scientific notation with exponent a power of two.
- `%e`:  scientific notation (`-1.234456e+78`
- `%E`:  scientific notation (`-1.234456E+78`)
- `%f`: decimal point but no exponent, e.g. `123.456`. Width is specified by an
  optional number immediately preceding the verb. Precision is specified after
  the (optional) width by a period followed by a number.

        %f     default width, default precision
        %9f    width 9, default precision
        %.2f   default width, precision 2
        %9.2f  width 9, precision 2
        %9.f   width 9, precision 0

- `%F`:  synonym for `%f`
- `%g`:  `%e` for large exponents, `%f` otherwise.
- `%G`:  `%E` for large exponents, `%F` otherwise

String and slice of bytes (treated equivalently with these verbs):
- `%s`: the uninterpreted bytes of the string or slice
- `%q`: a double-quoted string safely escaped with Go syntax
- `%x`: base 16, lower-case, two characters per byte
- `%X`: base 16, upper-case, two characters per byte

Slice:
- `%p`: address of 0th element in base 16 notation, with leading `0x`

Pointer:
- `%p`: base 16 notation, with leading `0x`


## Enumerations

- TODO: type MyEnum int + iota

### Errors

It's common to declare errors at one place and then have them returned later.

    var (
        ErrInternal      = errors.New("regexp: internal error")
        ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
        ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    )

    ...

    return nil, ErrUnmatchedLpar

TODO: https://godoc.org/github.com/pkg/errors

## Slices

The zero-value for a slice is a zero capacity slice. No need to use `make()`.

    var v []string
    v = append(v, "foo", "bar")  // we can append without make()

    s := make([]string, 3)       // create slice of 3 zero-valued strings
    s[0] = "a"
    s[1] = "b"
    s[2] = "c"
    fmt.Println(s[:])    // "abc"
    fmt.Println(s[1:])   // "bc"
    fmt.Println(s[1:2])  // "b"
    fmt.Println(s[1:3])  // "bc"
    fmt.Println(s[:2])   // "ab"

Iterate:

    for item := range v { ... }

    for index, item := range v { ... }



Merge two slices:

    var v1 := []string{"foo", "bar"}
    var v2 := []string{"baz"}
    v1 = append(v1, v2...)



TODO:

TODO: sorting and searching

## Maps

    m := make(map[string]int)
    m["a"] = 1
    m["b"] = 2
    delete(m, "b")

If the requested key doesn't exist, we get the value type's zero value.

    m["c"] // -> 0


    // optional second return value marks presence of key
    if _, ok := m["foo"]; ok {
        fmt.Println("contains key foo")
    }

    // Litteral map
    n := map[string]int{"foo": 1, "bar": 2}

    // range over keys and values
    for k, v := range m {
        fmt.Printf("%s -> %s\n", k, v)
    }

    // range over keys only
    for k := range m {
        fmt.Printf("key: %s\n", k)
    }


TODO: `_, ok := m["route"]`
TODO: https://blog.golang.org/go-maps-in-action


## Strings

Convert string to bytes:

    []byte("Here is a string....")

Convert bytes to string:

     string(byteArray[:])

Use a `ByteBuffer` as an `io.Writer` to capture a string:

    var buf bytes.Buffer
    fmt.Fprintf(&buf, "hello world")
    buf.String() // "hello world"

TODO: format


## I/O and files

Check if a file/directory exists

    if _, err := os.Stat("/path/to/whatever"); os.IsNotExist(err) {
        return err
    }

Create a directory:

    // error is of type *os.PathError
    err := os.Mkdir("/my/dir", 0744)
    err := os.MkdirAll("/my/dir", 0744)

Read an entire file into a string:

    data, err := ioutil.ReadFile("/tmp/dat")

Open a file for reading:

     f, err := os.Open("/tmp/dat")
     if err != nil { ... }
     defer f.Close()

Open a file for writing:

     f, err := os.OpenFile("/tmp/dat", os.O_WRONLY|os.O_CREATE, 0644)
     if err != nil { ... }
     defer f.Close()

Read line-by-line with `Scanner`:

     s := bufio.NewScanner(f)
     for s.Scan() {
         fmt.Printf(s.Text() + "\n")
     }

Read line-by-line with a `bufio.Reader`:

    r := bufio.NewReader(f)
    for {
        line, err := r.ReadString('\n')
        fmt.Print(line)
        if err != nil {
            if err == io.EOF {
                break
            } else {
                return fmt.Errorf("failed to read line: %s", err)
            }
        }
    }



### JSON

- TODO: annotations, unmarshal
- TODO: only exported struct names are unmarshalled!


- TODO: stream parsing (one entry at a time)

### XML parsing

Stream-based parsing (one entry at a time). Suitable for very large files.

    // element to be parsed from XML stream
    type Product struct {
        Name string `xml:"name,attr"`
        Type string `xml:"type,attr"`
    }

    ...

    src, _ := os.Open(xmlPath)
    defer src.Close()

    decoder := xml.NewDecoder(src)
    for {
        token, _ := decoder.Token()
        switch elem := token.(type) {
        case xml.StartElement:
            // If we just read a StartElement token and its name is "prod-item"
            if elem.Name.Local == "prod-item" {
                var product Product
                _ := decoder.DecodeElement(&cpeItem, &elem)
                // do something with product ...
            }
        default:
            log.Debug().Msgf("ignoring token %s", elem)
        }
    }

    if err == io.EOF {
        // normal exit
        return nil
    }


### Database

- TODO

### Logging

- TODO: zerolog


### Command-line parsing

- TODO: viper/cobra

### Goroutines and channels

### Tests
Tests are written in files ending in `_test.go` and use the `testing` package.

    import "testing"

    func TestSum(t *testing.T) {
        total := Sum(5, 5)
        if total != 10 {
           t.Errorf("Sum was incorrect, got: %d, want: %d.", total, 10)
        }
    }

Run tests via:

    go test -v
    go test -v ./pkg/...

With coverage

    go test -v -cover -coverprofile=coverage/coverage.txt ./pkg/... ./cmd/...
    # view in browser
    go tool cover -html coverage/coverage.txt

Table-driven tests are common in Go:

    func TestSum(t *testing.T) {
        tables := []struct {
            x int
            y int
            n int
        }{
            {1, 1, 2},
            {1, 2, 3},
            {2, 2, 4},
            {5, 2, 7},
        }

        for _, table := range tables {
            total := Sum(table.x, table.y)
            if total != table.n {
                t.Errorf("Sum of (%d+%d) was incorrect, got: %d, want: %d.", table.x, table.y, total, table.n)
            }
        }
    }

### stretchr/testify
Libraries like https://github.com/stretchr/testify can be used to simplify
testing:

    package yours

    import (
      "testing"
      "github.com/stretchr/testify/assert"
    )

    func TestSomething(t *testing.T) {
      assert.Equal(t, 123, 123, "they should be equal")
      assert.NotEqual(t, 123, 456, "they should not be equal")
      assert.Nil(t, object)
      if assert.NotNil(t, object) {
        assert.Equal(t, "Something", object.Value)
      }
    }

Every `assert` func returns a bool indicating whether the assertion was
successful or not, this is useful for if you want to go on making further
assertions under certain conditions.

To test many things you can also avoid specifying the `t` variable by:

    assert := assert.New(t)
    assert.Equal(123, 123, "they should be equal")
    assert.NotEqual(123, 456, "they should not be equal")

The `require` package provides same global functions as the assert package, but
instead of returning a boolean result they terminate current test.

    func TestSomething(t *testing.T) {
      require.Equal(t, 123, 456, "not equal, terminating test ...")
      // will not run
      require.Equal(t, 123, 123, "expected to be equal")


One can also test that a given function panics:

        failingFunc := func() {
            GoCrazyAndPanic()
        }

        assert.Panics(t, failingFunc)


## Mocking
A simple `mock` package https://github.com/stretchr/testify#mock-package:
As an example:

    type Runner interface {
        // Run executes an external command as a sub-process.
        Run(command *Command) error
    }

    // RunnerMock is a mocked object that implements the Runner interface
    type RunnerMock struct {
        mock.Mock
    }

    func (m *RunnerMock) Run(cmd *Command) error {
        args := m.Called(cmd)
        return args.Error(0)
    }

    func TestSomething(t *testing.T) {
            ...
            callerOfRunner := Caller{mockRunner}

            //
            // set up mock expectations
            //

            // On successful executions, these Run() calls should be made
            mockRunner.On("Run", expectedCmd1).Return(nil)
            mockRunner.On("Run", expectedCmd1).Return(nil)

            //
            // make calls
            //
            err := callerOfRunner.Call()
            assert.Nil(err, "expected Prepare() call to succeed")

             // verify that expected mock calls were made
            mockRunner.AssertExpectations(t)
    }
