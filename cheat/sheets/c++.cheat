## The tour

## Language basics

C++ is a compiled language. Each source file is processed by a compiler,
producing object files, which are combined by a linker into an executable.

An executable program is created for a specific hardware/system combination; it
is not portable, say, from a Mac to a Windows PC. When we talk about portability
of C++ programs, we usually mean portability of source code; that is, the source
code can be successfully compiled and run on a variety of systems.

The ISO C++ standard defines two kinds of entities:
- Core language features (built-in types, language constructs).
- The standard library.

C++ is statically typed. The type of every entity (e.g., object, value, name,
and expression) must be known to the compiler at its point of use.

- A *type* defines a set of possible values and operations (for an object).
- An *object* is some memory that holds a value of some type.
- A *value* is a set of bits interpreted according to a type.
- A *variable* is a named object.

Each *fundamental type* corresponds directly to hardware facilities and has a
fixed size that deter- mines the range of values that can be stored in it.

The size of a type is implementation-defined and can be found out with the
`sizeof` operator.

    sizeof(int)  // often 4

Sizes of C++ objects are expressed in terms of multiples of the size of a
`char`, so by definition the size of a `char` is `1`. It is *guaranteed* that:

- a `char` has at least 8 bits
- a `short` at least 16 bits
- a `long` at least 32 bits

`sizeof` and `<limits>` can be used to find sizes.

    cout << "size of long: " << sizeof(1L) << "\n";
    cout << "largest float: " << std::numeric_limits<float>::max() << "\n";

## Initialization

C++ offers different notations for expressing initialization, such as the
universal form based on *initializer lists* `{}` and `=`. The `{}`-list form
prevents narrowing conversions (that would lose information):

    double d1 = 2.3;
    double d2 {2.3};
    std::complex<double> z = 1;
    std::complex<double> z2 {d1,d2};
    std::complex<double> z3 = {1,2};  // the = is optional
    std::vector<int> v {1,2,3,4,5,6}; // a vector of ints

`auto` can be used as type when the type can be deduced from the initializer:

    auto b = true;    // a bool
    auto ch = 'x';    // a char
    auto i = 123;     // an int
    auto d = 1.2;     // a double
    auto z = sqrt(y); // z has the type of whatever sqr t(y) returns

    // place a copy of each value in v in x
    int v[] = {0,1,2}
    for (auto x : v) {
        cout << x << "\n";
    }

    // have x refer to each element in v
    int v[] = {0,1,2}
    for (auto& x : v) {
        x++;
    }

    // modifiers such as const can be used
    for (const auto& x : v) { ... }

## Constants

C++ supports two notions of immutability:
- `const`: primarily used to specify interfaces, so that data can be passed to
  functions without fear of it being modified. The compiler enforces constness.
- `constexpr` : "to be evaluated at compile time". Primarily to specify
  constants. A function to be used in constant expressions must be declared
  `constexpr` (such functions must be "simple").

## Pointers, arrays, loops

     T a[n];  // T[n]: array of n Ts
     T∗ p;    // T*: pointer to T
     T& r;    // T&: reference to T
     T f(A);  // T(A): function taking argument of type A and returning T

In an expression, prefix unary `∗` means "contents of" and prefix unary `&`
means "address of". In a declaration, `&` means "reference to".

    char∗ p = &v[3]; // p points to v’s four th element
    char x = ∗p;     // *p is the object that p points to
    char& r = x;

`nullptr` is used to represent "no object available". `0` and `NULL` are often
seen in older code.


---------



## Types and declarations
(The C++ Programming Language, Chapter 6)

C++ has a set of *fundamental types* corresponding to the most common basic
storage units of a computer and the most common ways of using them to hold data:

- Boolean: `bool`
  - `true == 1` and `false == 0` when converted to integer
  - in arithmetic and logical expressions: `0 == false` and `nonzero == true`
  - a pointer can implicitly be converted to `bool`:

        if (p) { ... }    // equivalent to if (p != nullptr) { ... }

- Character types:
  - `char`: default character type for program text. Usually 8 bits. Safe to
    assume that the character set includes decimal digits, english alphabet
    letters, and basic punctuation. Whether `char` is signed or unsigned is
    implementation-defined. One solution is to avoid plain `char`.
    Literal: `'a'`.
  - `signed char`: like char but guaranteed to be signed, capable of holding
    both positive and negative values.
  - `unsigned char`: like char but guaranteed to be unsigned.
  - `wchar_t` : for larger character sets such as Unicode. Size is impl-defined,
    but large enough to hold the largest character set supported by the
    implementation’s locale.
    Literal: `L'a'`.
  - `char16_t`: for holding 16-bit character sets, such as UTF-16.
    Literal: `u'a'`.
  - `char32_t`: for holding 32-bit character sets, such as UTF-32.
    Literal: `U'a'`

- Integer types: come in "plain", `signed` and `unsigned` and four sizes:
  - `short int` (aka `short`)
  - plain `int`
  - `long int` (aka `long`)
  - `long long int` (aka `long long`).

  Can use `int16_t`, `int64_t` and friends from `<cstdint>` for more control.
  `size_t` from `<cstddef>` is an unsigned int that can hot the size in bytes of
  every object.
  - Literals:

        int i = 99;    // decimal literal
        int i = 077;   // octal literal - leading '0'
        int i = 0xff;  // hexadecimal literal - leading '0x'

- Floating-point types:
  - `float` (single precision)
  - `double` (double precision)
  - `long double` (extended precision)
  - Literals: `1.23` `.23` `0.23` `1.2e10` `1.23e−15`

- Void type: `void`

        void∗ pv;  // pointer to object of unknown type

String literals:

    auto s0 =   "hello"; // const char*
    auto s1 = u8"hello"; // const char*, encoded as UTF-8
    auto s2 =  L"hello"; // const wchar_t*
    auto s3 =  u"hello"; // const char16_t*, encoded as UTF-16
    auto s4 =  U"hello"; // const char32_t*, encoded as UTF-32

    // Raw string literals containing unescaped \ and "
    auto R0 =   R"("Hello \ world")"; // const char*
    auto R1 = u8R"("Hello \ world")"; // const char*, encoded as UTF-8
    auto R2 =  LR"("Hello \ world")"; // const wchar_t*
    auto R3 =  uR"("Hello \ world")"; // const char16_t*, encoded as UTF-16
    auto R4 =  UR"("Hello \ world")"; // const char32_t*, encoded as UTF-32

    // Combining string literals with standard s-suffix
    auto S0 =   "hello"s; // std::string
    auto S1 = u8"hello"s; // std::string
    auto S2 =  L"hello"s; // std::wstring
    auto S3 =  u"hello"s; // std::u16string
    auto S4 =  U"hello"s; // std::u32string

We can construct other types using declarator operators:
- Pointer types: `int∗`
- Array types: `char[]`
- Reference types: `double&`, `vector<int>&&`

A user can also define user-defined types:
- Classes: `struct`s and `class`es
- Enumeration types (specific sets of values): `enum`, `enum class`


*Initialization*:
An initializer can use one of four syntactic styles:

    X a1 {v};    // recommended: introduced in C++11. no narrowing conversions.
    X a2 = {v};  // common in C
    X a3 = v;    // common in C
    X a4(v);     // function-style initializer (use constructor)

Prefer initializer `{}` unless the type is `auto`, then use `=`.

    auto i1 = 99;   // i1 is an int
    auto i2 = {99}; // warning: i2 is an std::initializer_list<int>

    vector<int> v1 {99}; // v1 is a vector of 1 element with the value 99
    vector<int> v2(99);  // warning: a vector of 99 elements (each with value 0)

The empty initializer list, `{}` , is used to indicate a default value.

    int x4 {};           // 0
    double d4 {};        // 0.0
    char∗ p {};          // nullptr
    vector<int> v4{};    // empty vector
    string s4 {};        // ""

Local variables and objects created on the free store (sometimes called dynamic
objects or heap objects) are not initialized by default unless they are
of user-defined types with a default constructor

    int x;                     // x does not have a well-defined value
    char buf[1024];            // buf[i] does not have a well-defined value
    int* p {new int};          // *p does not have a well-defined value
    char* q {new char[1024]};  // q[i] does not have a well-defined value

    string s;                  // s=="" because of string’s default constructor
    vector<char> v;            // v=={} because of vector’s default constructor

    string* ps {new string};   // *ps is "" because of string’s default constr

Use `{}` to initialize local/new-created local variables:

    int x {};                  // x is 0
    char buf[1024] {};         // buf[i] is 0 for all i

    int* p {new int{10}};      // *p is 10
    char* q {new char[1024]{}};  // q[i] is 0 for all i

Complex objects can also be created with initializer lists (note: the `=` is
redundant):

    int a[] = { 1, 2 };             // array initializer
    struct S { int x, string s };
    S s = { 1, "Helios" };          // struct initializer
    complex<double> z = { 0, pi };  // uses constructor
    vector<int> v = { 0, 1, 2, 3 }; // uses list constructor

*decltype*:
To deduce a type we can use `decltype(expr)`. This is typically used in generic
programming to express types that depend on template parameters:

    // return type can be deduced since C++14
    template<typename T, typename U>
    auto add(T t, U u) -> decltype(t + u)
    {
        return t+u;
    }

*L-values and R-values*:

- L-value: an expression that refers to an object. ("something that can be on
  the left-hand side of an assignment").
- R-value: roughly means "a value that is not an lvalue", such as a temporary
  value like the value returned by a function.

*Lifetimes*:

The *lifetime* of an object starts when its constructor completes and ends when
its destructor starts executing. Objects of types without a declared
constructor, such as an `int`, can be considered to have default constructors
and destructors that do nothing.

We can classify objects based on their lifetimes:
- Automatic: an object declared in a function is created when its definition is
  encountered and destroyed when its name goes out of scope. Typically
  stack-allocated.
- Static: objects declared in global or namespace scope and statics declared in
  functions or classes are created and initialized once (only) and "live" until
  the program terminates (§15.4.3).
- Free store: Using the new and delete operators, we can create objects whose
  lifetimes are controlled directly.
- Temporary objects (e.g., intermediate results in a computation or an object
  used to hold a value for a reference to const argument): their lifetime is
  determined by their use. Typically, temporary objects are automatic.
- Thread-local objects; that is, objects declared `thread_local`: such
  objects are created and destroyed with their thread.

*Type aliases*:

The `using` keyword can be used to define type aliases:

    using Pchar = char∗; // pointer to character
    using PF = int(∗)(double); // pointer to function: f(double) -> int

For good and bad, type aliases are synonyms for other types rather than distinct
types.

An older syntax with `typedef` fulfills the same purpose:

    typedef int int32_t;      // equivalent to "using int32_t = int;"
    typedef short int16_t;    // equivalent to "using int16_t = short;"
    typedef void(∗PtoF)(int); // equivalent to "using PtoF = void(*)(int);"




## Pointers, Arrays, References
(The C++ Programming Language, Chapter 7)

*Pointers*:

For a type `T` , `T∗` is the type "pointer to T". In declarations, `*` is a
suffix to the type name. In expressions, it's the dereference operator.

    char  c = 'a';
    char∗ p = &c; // p holds the address of c; & is the address-of operator
    char c2 = ∗p; // c2 == ’a’; * is the dereference operator

    int∗ pi;          // pointer to int
    char∗∗ ppc;       // pointer to pointer to char
    int∗ ap[15];      // array of 15 pointers to ints
    int (∗fp)(char∗); // pointer to function of type f(char*) -> int
    int∗ f(char∗);    // function with char* argument; returns a pointer to int

`void *` is a "pointer to an object of unknown type":

    int∗ pi = &i;

    void∗ pv = pi; // ok: implicit conversion of int* to void*
    ∗pv;           // error : can’t dereference void*
    ++pv;          // error : can’t increment (size of type pointed to unknown)

    int∗ pi2 = static_cast<int∗>(pv); // explicit conversion back to int*

The primary use for `void∗` is for passing pointers to/from functions not
allowed to make assumptions about types. Typically only seen in low-level system
calls (like `malloc`).

    void* alloc(size_t n);

Use `nullptr` (instead of `NULL` or `0`) to make code more readable.

    int* pi = nullptr;

*Arrays*:

Arrays are can be accessed with pointers (and pointer arithmetic):

    int v[] = { 1, 2, 3, 4 };
    int∗ p1 = v;       // pointer to v[0]
    int∗ p2 = &v[0];   // pointer to initial element (p1 == p2)
    int∗ p3 = v+4;     // pointer to one-beyond-last element

In fact array subscripting is defined in terms of pointer operations:

    a[j] == ∗(&a[0]+j) == ∗(a+j) == ∗(j+a) == j[a]

Curiously enough this is always true: `a[j] == j[a]`.

Pointer arithmetic depends on the size of the type `T`. `p+1` will be
`sizeof(T)` larger than (the integer value of) `p`.

Arrays cannot be passed by-value. An array is passed as a pointer to its first
element. When used as a parameter, the first dimension of an array is simply
treated as a pointer. Any array bound specified is ignored. Either pass the
length of the array as second argument or use `std::array`, `std::vector`,
`std::string`).

    void f(double arg[10]) {}  // these are equivalent
    void f(double *arg) {}

A multidimensional array is laid out as a sequence of elements in memory
(`m[3][5]` laid out as `m[15]`). For multi-dimensional arrays, you need to pass
the first dimension as an explicit argument:

    void print1(int m[][5], int dim1) {
        for (int i = 0; i != dim1; i++) {
            for (int j = 0; j != 5; j++)
              cout << m[i][j] << '\t';
        }
    }

    // equivalently, but obscure
    void print2(int *m, int dim1, int dim2) {
        ...
             cout << *(m + i*dim2 + j) << '\t';
    }

    int v[3][5] = { {0,1,2,3,4}, {10,11,12,13,14}, {20,21,22,23,24} };
    print1(v, 5);
    print2(&v[0][0], 3, 5);

For most cases, `std::array` or `std::vector` should be preferred as a safer
alternative.

*Const*:

C++ offers two related meanings of "constant":
- `constexpr`: Evaluate at compile time.
- `const` : Do not modify in this scope.

To express this notion of immutability after initialization, we can add const to
the definition of an object. An object declared const cannot be assigned to, it
must be initialized.

    const int model = 90;            // model is a const
    const int v[] = { 1, 2, 3, 4 };  // v[i] is a const
    const int x;                     // error : no initializer

    // declaring something const ensures that its value will not change within
    // its scope:

    model = 200; // error
    v[2] = 3;    // error

Note that `const` modifies a type; it restricts how an object can be used.

    void g(const T∗ p) { // cannot modify *p here }

    void h() {
        T val;   // can modify val here
        g(&val); // val cannot be modified here
    }

Prefixing a declaration of a pointer with `const` makes the object, but not the
pointer, a constant. To declare a pointer itself, rather than the object pointed
to, a constant, we use the *declarator operator* `∗const` instead of plain `∗`.

    char s[] = "hello";

    char ∗const cp = s;        // const pointer to char
    char const∗ pc = s;        // pointer to const char
    const char∗ pc2 = s;       // pointer to const char (equivalent to pc)
    const char ∗const cpc = s; // const pointer to const


    cp[3] = 'a';  // OK
    cp = p;       // error: cp is constant

    pc[3] = 'g';  // error : pc points to constant
    pc = p;       // OK

    cpc[3] = 'a'; // error : cpc points to constant
    cpc = p;      // error : cpc is constant


*References*:

Like a pointer, a reference is an alias for an object. It is usually implemented
to hold a machine address of an object (no performance overhead compared to
pointers). There is no "null reference" - a reference always refers to an
object.

To reflect the lvalue/rvalue and const /non- const distinctions, there are three kinds of references:

- *lvalue references*: refers to object whose value we want to change
- *const references*: refers to object whose value we do not want to change
- *rvalue references*: refers to objects whose value we do not need to preserve
  after we have used it (e.g., a temporary). We want to know if a reference
  refers to a temporary, because if it does, we can sometimes turn an expensive
  copy operation into a cheap move operation. An object (such as a `string` or a
  `list`) that is represented by a small descriptor pointing to a potentially
  huge amount of information can be simply and cheaply moved if we know that the
  source isn’t going to be used again.

Examples:

    string var {"Cambridge"};
    string f();

    string& r1 {var};         // lvalue reference, bind r1 to var (an lvalue)
    string& r2 {f()};         // error : f() is an rvalue
    string& r3 {"Princeton"}; // error : cannot bind to temporar y
    const string cr1& {"Harvard"}; // OK: make temporary and bind to cr1

    string&& rr1 {f()};      // rvalue reference, bind rr1 to temporary
    string&& rr2 {var};      // error : var is an lvalue
    string&& rr3 {"Oxford"}; // rr3 refers to a temporary holding "Oxford"



    string a(x);         // x is an lvalue
    string b(x + y);     // x + y is an rvalue
    string c(get_str()); // return value from get_str() is an rvalue

The `&&` declarator operator means "rvalue reference". We do not use `const`
rvalue references; most of the benefits from using rvalue references involve
writing to the object to which it refers. Both a `const` lvalue reference and an
`rvalue` reference can bind to an rvalue. However, the purposes will be
fundamentally different:

- We use rvalue references to implement a "destructive read" for optimization of
  what would otherwise have required a copy.
- We use a `const` lvalue reference to prevent modification of an argument.

The `std::move()` function can be used to turn an lvalue into an rvalue
reference.

    string x;

    string new_x {std::move(x)};  // NOTE: x may NOT be used from this point on
    // string new_x {static_cast<string&&>(x); // equivalent

All standard-library containers provide move constructors and move assignment.
Also, their operations that insert new elements, such as `insert()` and
`push_back()`, have versions that take rvalue references.

References can be used as return values, for example, when a function can be
used both on the left-hand and right-hand sides of an assigmnent.

    class list {
    public:
        int& operator[] (const int index);
        const int& operator[] (const int index) const;
    };

    list l {1,2,3};
    cout << l[0];   // uses const int& operator[]
    l[0] = 1;       // uses int& operator[]

## Structures, unions, and enumerations
(The C++ Programming Language, Chapter 8)

    struct Address {
        const char∗ name;
        int number;
        const char∗ street;
        const char∗ town;
        char state[2];
    };

    // Can initialized via memberwise intialization.
    Address jd = { "Jim Dandy", 61, "South St", "New Providence", {'N','J'} };

A `struct` is a simple form of class with all members `public`. So a struct can
have member functions and even constructors. A constructor is needed if you need
to reorder arguments, validate or modify arguments.

    struct Points {
        vector<Point> elem;// must contain at least one Point
        Points(Point p0) { elem.push_back(p0);}
        // ...
    };
    Points x0;               // error : no default constructor
    Points x1{ {100,200} };

The name of a type becomes available for use immediately after it has been
encountered and not just after the complete declaration has been seen. However,
it is not possible to declare new objects of a struct until its complete
declaration has been.

    // OK
    struct Link {
        Link∗ previous;
        Link∗ successor;
    };

    // error: recursive definition
    //        the compiler is not able to determine the size of No_good
    struct No_good {
        No_good member;
    };

To allow two structs to refer to each other:

    struct List; // struct name declaration: List to be defined later

    struct Link {
        Link∗ pre;
        Link∗ suc;
        List∗ member_of;
        int data;
    };

    struct List {
        Link∗ head;
    };

Sometimes, we want to treat an object as just "plain old data" (POD) (a
contiguous sequence of bytes in memory) and not worry about more advanced
semantic notions, such as run-time polymorphism, user-defined copy semantics,
etc. Often, the reason is to be able to move objects around in the most
efficient way (e.g. via `std::memcpy()`). So, a POD is an object that can be
manipulated as "just data" without worrying about complications of class
layouts or user-defined semantics for construction, copy, and move. For example:

    struct S0 { };        // POD
    struct S1 { int a; }; // POD

    // no POD (no default constructor)
    struct S2 { int a; S2(int aa) : a(aa) { } };
    // no POD (user-defined default constructor)
    struct S3 { int a; S3(int aa) : a(aa) { } S3() {} };
    // POD (has a default constructor)
    struct S4 { int a; S4(int aa) : a(aa) { } S4() = default; };
    // no POD (has a virtual function)
    struct S5 { virtual void f(); /* ... */ };


    struct S6 : S1 { };         // POD
    struct S7 : S0 { int b; };  // POD
    struct S8 : S1 { int b; };  // not a POD (data in both S1 and S8
    struct S9 : S0, S1 {};      // POD

The `is_pod<T>::value` type property predicate from `<type_traits>` can
determine if a type is a POD.

A `union` is a struct in which all members are allocated at the same address so
that the union occupies only as much space as its largest member. A `union` can
only hold a value for one member at a time.

    union Value {
        char∗ s;
        int i;
    };

The language doesn’t keep track of which kind of value is held by a union , so
the programmer must do that:

    struct Entry {
        char∗ name;
        Type t;
        Value v; // use v.s if t==str; use v.i if t==num
    };

    void f(Entry∗ p) {
        if (p−>t == str)
            cout << p−>v.s;
        // ...
    }

There are two kinds of enumerations:
1. `enum classes`, for which the enumerator names (e.g., red ) are local to the
  `enum` and their values do not implicitly convert to other types.
2. "Plain `enums`" for which the enumerator names are in the same scope as the
   enum and their values implicitly convert to integers.

In general, prefer `enum class`es because they cause fewer surprises.

    enum class Traffic_light { red, yellow, green };
    enum class Warning { green, yellow, orang e, red }; // fire alert levels

    Warning a1 = 7;               // error: no int->Warning conversion
    int a2 = green;               // error : green not in scope
    int a3 = Warning::green;      // error: no Warning->int conversion
    Warning a4 = Warning::green;  // OK


## Statements
(The C++ Programming Language, Chapter 9)

It is usually a good idea to introduce the variable into the smallest scope
possible. A variable can be declared in a condition:

    if (double d = prim(true)) {
        left /= d;
        break;
    }

A `break` breaks out of the nearest enclosing switch or iteration statement.

## Expressions
(The C++ Programming Language, Chapter 11)

Some operators:
- `typeid(type)`: type identification
- `typeid(expr)`: runtime type identification
- `dynamic_cast<type>(expr)`: runtime checked conversion
- `static_cast<type>(expr)`: compile-time checked conversion
- `reinterpret_cast<type>(expr)`: unchecked conversion
- `const_cast<type>(expr)`: const conversion
- `sizeof expr`: size of object
- `sizeof(type)`: size of type

There are alternate keywords for the operators:

- `and`: `&`
- `or`: `|`
- `not`: `!`
- `xor`: `^`
- `and_eq`: `&=`
- `or_eq`: `|=`
- `not_eq`: `!=`
- `xor_eq`: `^=`
- `bitand`: `&`
- `bitor`: `|`
- `compl`: `~`

For example:

    bool b = not (x or y) and z;
    int x4 = ~(x1 bitor x2) bitand x3;

is equivalent to:

    bool b = !(x || y) && z;
    int x4 = ~(x1 | x2) & x3;

*Order of evaluation*: 
The order of evaluation of subexpressions within an
expression is undefined. In particular, you cannot assume that the expression is
evaluated left-to-right.

    int x = f(2)+g(3); // undefined whether f() or g() is called first
    v[i] = i++;        // undefined result: evaluated as either v[1]=1 or v[2]=1

The operators `,` (comma), `&&` (logical and), and `||` (logical or) guarantee
that their left-hand operand is evaluated before their right-hand operand.


## Functions
(The C++ Programming Language, Chapter 12)

## Exceptions
(The C++ Programming Language, Chapter 13)

## Namespaces
(The C++ Programming Language, Chapter 14)

## Classes (user-defined types)
(The C++ Programming Language, Chapter 16)


## Concurrency


## Tools
- Compiler: clang, g++
- Build/packaging: CMake

## Project structure

## CMake
CMake is a build file generator that uses a compiler-independent configuration
language. It enables building, testing and packaging of software. It is
cross-platform and can generate build files for different tools (make, xcode,
ninja, vs).
