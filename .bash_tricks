# * mcd -- cd to a directory, making it first if it does not exist;
# * forall [pattern] [command] -- performs command for all files 
#                                 matching pattern;
# * fullpath [file] -- prints the full path of the specified file;
# *                    .., ..., ...., etc -- goes up 1, 2, 3, etc steps 
#                      in the directory  tree without you having to type 
#                      "cd " first (handier than you think);
# * anchor [name] -- creates an anchor/bookmark at your current directory 
#                    location (leaving out name sets the empty anchor);
# * visit [name] -- immediately goes to the location of the named 
#                   anchor -- supports autocomplete;
# * ignore .svn directories when you tab-complete in bash;
# * svn-add-unknown -- adds all unknown files to SVN;
# * svn-remove-deleted -- removes locally deleted files from the SVN server;
# * alert -- tack on "; alert" to the command line after a long-running command
#            and you will get a bubble in your OSX environment when the program 
#            completes. Ubuntu already has this by default. 

# change to directory (and create it if it does not exist)
mcd () {
  if [ -d $1 ]; then
    cd $1
  else
    mkdir -p $1 && cd $1
  fi
} 

# for all 'something' perform xxxxx
forall () {
  PATTERN=$1
  shift
  find . -name "$PATTERN" -exec $@ {} \; 2>/dev/null
}

# fullpath of file(s)
fullpath() {
while [ $# -ne 0 ]; do
      ls -1 $(pwd)/"$1"
      shift
  done
}

# easier navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'
alias .......='cd ../../../../../..'
alias ........='cd ../../../../../../..'


#Tabcompletions for Anchor / Visit
_anchor_visit_tabcomp () {
    local curw
    COMPREPLY=()
    curw=${COMP_WORDS[COMP_CWORD]}
    for path in `compgen -d ~/.anchors/$curw`; do
        COMPREPLY=(${COMPREPLY[@]-} $(basename $path))
    done
    #COMPREPLY=($(compgen -d ~/.anchors/$curw | xargs basename -a))
    return 0
}

complete -F _anchor_visit_tabcomp -o dirnames anchor
complete -F _anchor_visit_tabcomp -o dirnames visit

#Anchor script for creating a directory anchor. '-d' flag removes an anchor
anchor () {
  ANCHOR_DIR=~/.anchors/

  if [ ! -d $ANCHOR_DIR ]; then
    mkdir $ANCHOR_DIR
  fi

  if [ $# -eq 0 ]; then
    NAME=default-anchor
  else
    NAME=$1
    if [ $NAME = "-d" ]; then
        if [ $# -eq 2 ]; then
            NAME=$2
            if [ ! -e $ANCHOR_DIR/$NAME ]; then
                echo "Anchor [${NAME}] not found!"
                return 1
            fi
            unlink $ANCHOR_DIR/$NAME 2> /dev/null
            echo "Anchor '"$NAME"' removed."
            return 0
        else
            echo "Usage is 'anchor -d <anchor_name_to_remove>"
            return 1
        fi
    fi

    if [ $# -gt 1 ]; then
      echo "Just supply one anchor name!"
      return 1
    fi
  fi

  unlink $ANCHOR_DIR/$NAME 2> /dev/null
  ln -s "`pwd -P`" $ANCHOR_DIR/$NAME
}

#Visit script for visiting anchors. '-p' means print instead of visit, -l means list 
#TODO: This can be rewritten more nicely to create help, a more neat structure for parsing arguments, etc.
visit () {
  ANCHOR_DIR=~/.anchors/

  if [ $# -eq 0 ]; then
    NAME=default-anchor
  else
    #List available anchors
    if [ $1 = "-l" ] || [ $1 = "--list" ]; then
      for l in `ls $ANCHOR_DIR`; do
        echo "$l => [`readlink ${ANCHOR_DIR}/$l`]"
      done
      return 0
    fi
    #Print anchor path
    if [ $1 = "-p" ] || [ $1 = "--print" ]; then
      if [ ! -e $ANCHOR_DIR/$NAME ]; then
        echo "Anchor [${NAME}] not found!"
        return 1
      fi
      echo "`readlink ${ANCHOR_DIR}/$2`"
      return 0
    fi
    #Print error if illegal arguments
    NAME=$1
    if [ $# -gt 1 ]; then
      echo "Just supply one anchor name!"
      return 1
    fi
  fi

  if [ ! -e $ANCHOR_DIR/$NAME ]; then
    echo "Anchor [${NAME}] not found!"
    return 1
  fi

  cd "`readlink $ANCHOR_DIR/$NAME`"
}

# ignore .svn directories while tab-completing
export FIGNORE=.svn
export HISTCONTROL=ignoreboth

# Add all unknown files in a directory to SVN
alias svn-add-unknown='svn st | grep ^\? | cut -c8- | xargs svn add'

# Remove all locally deleted files in a directory from SVN
alias svn-remove-deleted='svn st | grep ^\! | cut -c8- | xargs svn rm --force'

if [ $OSTYPE == "darwin11" ]; then
  alias alert='growlnotify -m  "Command completed: $(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')" "$([ $? = 0 ] && echo terminal || echo error)"'
fi
